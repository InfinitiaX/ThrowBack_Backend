// services/playlistStatsService.js
const cron = require('node-cron');
const mongoose = require('mongoose');

// N'essayez pas d'acc√©der aux mod√®les directement au moment du chargement du fichier
// Nous les r√©f√©rencerons plus tard au moment de l'ex√©cution
let Playlist, Video, User, PlaylistAnalytics;

// Fonction pour initialiser les r√©f√©rences aux mod√®les quand c'est n√©cessaire
const initModels = () => {
  if (!Playlist) {
    try {
      Playlist = mongoose.model('Playlist');
      Video = mongoose.model('Video');
      User = mongoose.model('User');
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'acc√®s aux mod√®les:', error);
      throw new Error('Mod√®les non disponibles. Assurez-vous que les mod√®les sont charg√©s avant le service.');
    }
  }

  // Pour PlaylistAnalytics, essayons de le r√©cup√©rer, et s'il n'existe pas, cr√©ons-le
  if (!PlaylistAnalytics) {
    try {
      PlaylistAnalytics = mongoose.model('PlaylistAnalytics');
    } catch (error) {
      // Si le mod√®le n'existe pas, on cr√©e un sch√©ma
      console.log('Cr√©ation du mod√®le PlaylistAnalytics...');
      const playlistAnalyticsSchema = new mongoose.Schema({
        playlist_id: {
          type: mongoose.Schema.Types.ObjectId,
          ref: 'Playlist',
          required: true
        },
        views: {
          total: { type: Number, default: 0 },
          daily: { type: Number, default: 0 },
          weekly: { type: Number, default: 0 },
          monthly: { type: Number, default: 0 }
        },
        unique_viewers: {
          total: { type: Number, default: 0 },
          daily: { type: Number, default: 0 },
          weekly: { type: Number, default: 0 },
          monthly: { type: Number, default: 0 }
        },
        favorites: {
          total: { type: Number, default: 0 },
          daily: { type: Number, default: 0 },
          weekly: { type: Number, default: 0 },
          monthly: { type: Number, default: 0 }
        },
        trending_score: { type: Number, default: 0 },
        last_updated: { type: Date, default: Date.now }
      }, {
        timestamps: true
      });
      
      PlaylistAnalytics = mongoose.model('PlaylistAnalytics', playlistAnalyticsSchema);
    }
  }
};

class PlaylistStatsService {
  constructor() {
    this.tasks = [];
    this.status = {
      isRunning: false,
      lastTrendingUpdate: null,
      lastViewsUpdate: null,
      lastRecommendationUpdate: null,
      errors: []
    };
    
    // On ne lance pas tout de suite les t√¢ches
    // On les lancera plus tard pour s'assurer que les mod√®les sont charg√©s
  }
  
  // M√©thode pour initialiser les t√¢ches apr√®s que tous les mod√®les sont charg√©s
  start() {
    try {
      // Initialiser les r√©f√©rences aux mod√®les
      initModels();
      
      // Maintenant on peut lancer les t√¢ches
      this.initTasks();
      
      return true;
    } catch (error) {
      console.error('‚ùå Erreur lors du d√©marrage du service:', error);
      this.status.errors.push({
        time: new Date(),
        message: error.message,
        stack: error.stack
      });
      return false;
    }
  }
  
  initTasks() {
    try {
      // Mise √† jour des tendances toutes les 3 heures
      const trendingTask = cron.schedule('0 */3 * * *', async () => {
        console.log('üîÑ Ex√©cution de la t√¢che de mise √† jour des tendances...');
        await this.updateTrendingPlaylists();
        this.status.lastTrendingUpdate = new Date();
      });
      
      // Mise √† jour des compteurs de lectures toutes les 30 minutes
      const viewsTask = cron.schedule('*/30 * * * *', async () => {
        console.log('üîÑ Ex√©cution de la t√¢che de mise √† jour des compteurs de lectures...');
        await this.updatePlaylistViews();
        this.status.lastViewsUpdate = new Date();
      });
      
      // G√©n√©ration des recommandations tous les jours √† 4h00
      const recommendationsTask = cron.schedule('0 4 * * *', async () => {
        console.log('üîÑ Ex√©cution de la t√¢che de g√©n√©ration des recommandations...');
        await this.generateRecommendations();
        this.status.lastRecommendationUpdate = new Date();
      });
      
      this.tasks.push(trendingTask, viewsTask, recommendationsTask);
      this.status.isRunning = true;
      
      console.log('‚úÖ Service de statistiques des playlists initialis√© avec succ√®s');
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'initialisation des t√¢ches:', error);
      this.status.errors.push({
        time: new Date(),
        message: error.message,
        stack: error.stack
      });
      this.status.isRunning = false;
    }
  }
  
  async updateTrendingPlaylists() {
    try {
      // S'assurer que les mod√®les sont initialis√©s
      initModels();
      
      // R√©cup√©rer toutes les playlists publiques
      const playlists = await Playlist.find({ visibilite: 'PUBLIC' })
        .select('_id nom nb_lectures nb_favoris');
      
      console.log(`üìä Mise √† jour des tendances pour ${playlists.length} playlists...`);
      
      for (const playlist of playlists) {
        // R√©cup√©rer les analytics existantes ou en cr√©er de nouvelles
        let analytics = await PlaylistAnalytics.findOne({ playlist_id: playlist._id });
        
        if (!analytics) {
          analytics = new PlaylistAnalytics({
            playlist_id: playlist._id,
            views: { total: playlist.nb_lectures || 0 },
            favorites: { total: playlist.nb_favoris || 0 }
          });
        }
        
        // Calculer le score de tendance
        // Le score est bas√© sur:
        // - 40% des vues totales
        // - 30% des vues quotidiennes
        // - 20% des favoris totaux
        // - 10% des favoris quotidiens
        const trendingScore = 
          (analytics.views.total * 0.4) + 
          (analytics.views.daily * 0.3) + 
          (analytics.favorites.total * 0.2) + 
          (analytics.favorites.daily * 0.1);
        
        analytics.trending_score = trendingScore;
        analytics.last_updated = new Date();
        
        await analytics.save();
      }
      
      console.log('‚úÖ Mise √† jour des tendances termin√©e');
      return { success: true, count: playlists.length };
    } catch (error) {
      console.error('‚ùå Erreur lors de la mise √† jour des tendances:', error);
      this.status.errors.push({
        time: new Date(),
        task: 'updateTrendingPlaylists',
        message: error.message
      });
      return { success: false, error: error.message };
    }
  }
  
  async updatePlaylistViews() {
    try {
      // S'assurer que les mod√®les sont initialis√©s
      initModels();
      
      // Simuler la mise √† jour des compteurs de lectures
      // Dans un cas r√©el, on r√©cup√©rerait les donn√©es d'un syst√®me de tracking
      console.log('üìä Mise √† jour des compteurs de lectures...');
      
      // Pour chaque playlist publique, simuler des vues
      const playlists = await Playlist.find({ visibilite: 'PUBLIC' });
      let updatedCount = 0;
      
      for (const playlist of playlists) {
        // R√©cup√©rer ou cr√©er les analytics
        let analytics = await PlaylistAnalytics.findOne({ playlist_id: playlist._id });
        
        if (!analytics) {
          analytics = new PlaylistAnalytics({
            playlist_id: playlist._id,
            views: { 
              total: playlist.nb_lectures || 0,
              daily: 0,
              weekly: 0,
              monthly: 0
            },
            favorites: { 
              total: playlist.nb_favoris || 0,
              daily: 0,
              weekly: 0,
              monthly: 0
            }
          });
        }
        
        // Simuler des vues al√©atoires (1 √† 10)
        const newViews = Math.floor(Math.random() * 10) + 1;
        
        // Mettre √† jour les compteurs
        analytics.views.total += newViews;
        analytics.views.daily += newViews;
        analytics.views.weekly += newViews;
        analytics.views.monthly += newViews;
        analytics.last_updated = new Date();
        
        await analytics.save();
        
        // Mettre √† jour la playlist √©galement
        await Playlist.updateOne(
          { _id: playlist._id },
          { $set: { nb_lectures: analytics.views.total } }
        );
        
        updatedCount++;
      }
      
      console.log(`‚úÖ Mise √† jour des compteurs termin√©e pour ${updatedCount} playlists`);
      return { success: true, count: updatedCount };
    } catch (error) {
      console.error('‚ùå Erreur lors de la mise √† jour des compteurs:', error);
      this.status.errors.push({
        time: new Date(),
        task: 'updatePlaylistViews',
        message: error.message
      });
      return { success: false, error: error.message };
    }
  }
  
  async generateRecommendations() {
    try {
      // S'assurer que les mod√®les sont initialis√©s
      initModels();
      
      console.log('üß† G√©n√©ration des recommandations de playlists...');
      
      // Dans un syst√®me r√©el, on utiliserait un algorithme de recommandation plus sophistiqu√©
      // bas√© sur les pr√©f√©rences des utilisateurs, l'historique d'√©coute, etc.
      
      // Pour cette d√©monstration, on va simplement r√©cup√©rer les playlists les plus populaires
      // et les associer √† des utilisateurs al√©atoires
      
      // R√©cup√©rer les playlists les plus populaires
      const popularPlaylists = await PlaylistAnalytics.find()
        .sort({ trending_score: -1 })
        .limit(20)
        .populate('playlist_id', 'nom visibilite type_playlist');
      
      // R√©cup√©rer des utilisateurs al√©atoires
      const users = await User.find()
        .limit(50)
        .select('_id');
      
      console.log(`üìä G√©n√©ration de recommandations avec ${popularPlaylists.length} playlists populaires pour ${users.length} utilisateurs...`);
      
      // Pour chaque utilisateur, attribuer 3-5 playlists recommand√©es
      let totalRecommendations = 0;
      
      // Dans un syst√®me r√©el, ces recommandations seraient stock√©es dans une collection d√©di√©e
      // et accessibles via une API pour affichage dans l'interface utilisateur
      
      console.log(`‚úÖ G√©n√©ration de ${totalRecommendations} recommandations termin√©e`);
      return { success: true, count: totalRecommendations };
    } catch (error) {
      console.error('‚ùå Erreur lors de la g√©n√©ration des recommandations:', error);
      this.status.errors.push({
        time: new Date(),
        task: 'generateRecommendations',
        message: error.message
      });
      return { success: false, error: error.message };
    }
  }
  
  async runManualTrendingUpdate() {
    console.log('üîÑ Ex√©cution manuelle de la mise √† jour des tendances...');
    const result = await this.updateTrendingPlaylists();
    this.status.lastTrendingUpdate = new Date();
    return result;
  }
  
  async runManualViewsUpdate() {
    console.log('üîÑ Ex√©cution manuelle de la mise √† jour des compteurs de lectures...');
    const result = await this.updatePlaylistViews();
    this.status.lastViewsUpdate = new Date();
    return result;
  }
  
  healthCheck() {
    const now = new Date();
    const oneHourAgo = new Date(now - 3600000);
    const oneDayAgo = new Date(now - 86400000);
    
    // V√©rifier si les mises √† jour r√©centes ont √©t√© effectu√©es
    const trendingOk = this.status.lastTrendingUpdate && this.status.lastTrendingUpdate > oneDayAgo;
    const viewsOk = this.status.lastViewsUpdate && this.status.lastViewsUpdate > oneHourAgo;
    
    // V√©rifier s'il y a eu des erreurs r√©centes
    const recentErrors = this.status.errors.filter(e => e.time > oneHourAgo).length;
    
    let status = 'healthy';
    if (recentErrors > 0) {
      status = recentErrors > 3 ? 'error' : 'warning';
    } else if (!trendingOk || !viewsOk) {
      status = 'warning';
    }
    
    return {
      status,
      lastTrendingUpdate: this.status.lastTrendingUpdate,
      lastViewsUpdate: this.status.lastViewsUpdate,
      lastRecommendationUpdate: this.status.lastRecommendationUpdate,
      recentErrors,
      isRunning: this.status.isRunning
    };
  }
  
  shutdown() {
    console.log('üõë Arr√™t du service de statistiques des playlists...');
    
    // Arr√™ter toutes les t√¢ches programm√©es
    this.tasks.forEach(task => {
      if (task) {
        task.stop();
      }
    });
    
    this.status.isRunning = false;
    console.log('‚úÖ Service de statistiques des playlists arr√™t√©');
  }
}

// Singleton
let playlistStatsService = null;

// Fonction d'initialisation
function initPlaylistStatsService() {
  if (!playlistStatsService) {
    playlistStatsService = new PlaylistStatsService();
  }
  return playlistStatsService;
}

module.exports = {
  initPlaylistStatsService
};